---
title: "Public health surveillance with surveil"
output: rmarkdown::html_vignette
header-includes:
   - \usepackage{amsmath}
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: bib.bib
link-citations: yes
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  results = "hold", 
  collapse = TRUE, 
  eval = TRUE,
  fig.pos = 'h', 
  fig.align = 'center'
)
```

This vignette demonstrates basic usage of **surveil** for public health surveilance. The package leverages the principles of Bayesian inference [@jaynes_2003;@mackay_2003;@harrel_2021] to infer population risk of disease or death given time series data consisting of case counts and population at risk. To facilitate analysis, the package contains special methods for age-standardization, printing and plotting results, as well as for measuring and visualizing inequality.

## Getting started

```{r message=FALSE, warning=FALSE, eval=T}
## packages required for the analysis
library(surveil)
library(dplyr)
library(ggplot2)
theme_set(theme_classic())

## for the vignette
library(knitr)
```

Surveillance data should minimally contain case counts, reliable population at risk estimates, and a discrete time period variable. They also may include one or more grouping variables (such as race-ethnicity). 

This vignette analyzes colorectal cancer incidence data by race-ethnicity, year, and Texas MSA, obtained through CDC Wonder. The race-ethnicity grouping includes (non-Hispanic) Black, (non-Hispanic) White, and Hispanic, and the MSAs include those centered on the cities of Austin, Dallas, Houston, and San Antonio.


```{r eval=T}
head(msa) %>%
  kable(booktabs = TRUE, 
        caption = "Glimpse of colorectal cancer incidence data (CDC Wonder)") 
```

**surveil**'s model fitting function, `stan_rw`, requires that the user provide a `data.frame` with specific columns. There must be one named `Cases` containing case counts, and `Population` containing population at risk. The user also must provide the name of the column containing the time period, and, optionally, a grouping factor. For the MSA data printed above, the grouping column is Race and the time column is Year.

## Time series surveillance models

## Preparing the data

We will first analyze aggregated CRC cases across Texas's top four MSAs. The `msa` data from CDC Wonder already has the necessary format (columns), but the data are dis-aggregated by MSA. So we first group the data by year and race, and then combine cases across MSAs.

The following code chunk aggregates the data using the `dplyr` package:

```{r message = FALSE, warn = FALSE, eval = T}
tx.msa <- msa %>%
  group_by(Year, Race) %>%
  summarise(Count = sum(Count),
            Population = sum(Population))
```

The following code provides a glimpse of the aggregated data (Table 2):

```{r eval = T}
head(tx.msa) %>%
  kable(booktabs = TRUE, 
        caption = "Glimpse of aggregated Texas metropolitan CRC cases, by race and year")
```

## Model specification

### The basics

The base **surveil** model specification is a Poisson random-walk, which is closely related to both state-space and Intrinsic Gaussian Markov random field (IGMRF) models. The Poisson model is used as the likelihood: the probability of observing a given number of cases, $c_t$, conditional on unknown level of risk, $\eta_t$, and known population at risk, $p_t$:
$$c_t \sim \text{Pois}(p_t \cdot \eta_t)$$
where $t$ indexes the time period. Since $\eta_t$ is a rate, we build a model for the log-rates, $log(\eta_t) = \phi_t$. The random walk structure states that our expectation for the rate at any time is its previous value, and we assign a Gaussian probability distribution to deviations from the previous value:
$$\phi_t \sim \text{Gau}(\phi_{t-1}, \tau^2)$$
This places higher probability on a smooth trend through time, specifically implying that the underlying risk of disease has less variation than we find in the raw observations.

The log-risk for time $t=1$ has no previous value to anchor its expectation; instead, we assign a prior probability distribution directly to $\phi_1$. **surveil** uses a Student's t distribution, which has three parameters: degrees of freedom, location, and scale. When the degrees of freedom are large (even > 20), it is comparable to the Gaussian distribution, otherwise somewhat greater probability is assigned to tail-area observations. The scale parameter, $\tau$, also requires a prior distribution, and again **surveil** uses a Student's t model.

### Multiple time series

For multiple time series, **surveil** allows users to add a correlation structure to the model. This allows our inferences about each population to be mutually informed by inferences about all other observed populations. For this model, given $k$ populations, the log-rates, $\boldsymbol \phi_t$, are assigned a multivariate Gaussian model:
$$\boldsymbol \phi_t \sim \text{Gau}(\boldsymbol \phi_{t-1}, \boldsymbol \Sigma),$$
where $\boldsymbol \Sigma$ is a $k \times k$ covariance matrix. The covariance matrix can be decomposed into a diagonal matrix containing scale parameters for each variable, $\boldsymbol \Delta = diag(\tau_1,\dots \tau_k)$, and a symmetric correlation matrix, $\boldsymbol \Omega$:
$$\boldsymbol \Sigma = \boldsymbol \Delta \boldsymbol \Omega \boldsymbol \Delta$$
When the correlation structure is added to the model, then a prior distribution is also required for the correlation matrix. **surveil** uses the LKJ model, which has a single shape parameter, $\alpha$.^[You can find more about the LKJ model in the Stan documentation. Note that the manual uses $\eta$ to symbolize the shape parameter.] If $\alpha=1$, the LKJ model will place uniform prior probability on any $k \times k$ correlation matrix; as $\alpha$ increases from one, it expresses ever greater skepticism towards large correlations. When $\alpha <1$, the LKJ model becomes 'concave'---expressing skepticism towards correlations of zero. 

## Fitting the model

The time series model is fit by passing surveillance data to the `stan_rw` function. Here, `Year` and `Race` indicate the appropriate time and grouping columns in the `tx.msa` data frame. 

```{r}
fit <- stan_rw(tx.msa, time = Year, group = Race)
```

We could add a correlation structure to the data by adding `cor = TRUE`, as opposed to the default, `cor = FALSE`). To speed things up, we could take advantage of parallel processing using the `cores` argument (e.g., `cores = 4` to run on 4 cores simultaneously). Note also that it is important to read and address any warning messages related to Stan's MCMC diagnostics. In this case, the sampling finished without any warnings, so we can proceed with our analysis.

## Visualizing results

The plotting method for **surveil** models returns a `ggplot` object. We can plot model results using `plot`:

```{r fig.width = 4, fig.height = 3.5}
plot(fit, scale = 100e3)
```

Or, we can store the ``ggplot` in our working environment, and then modify the figure as we please:

```{r fig.width = 4, fig.height = 3.5}
fig <- plot(fit, scale = 100e3)
fig +
  scale_x_continuous(breaks = 1999:2017, 
                     name = NULL) +
  scale_colour_brewer(
    breaks = c("Black or African American",
               "Hispanic",
               "White"),
    labels = c("Black", 
               "Hispanic", 
               "White"),
    type = "qual",
    palette = "Dark2"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
```

## Measuring pairwise inequality

A selection of complementary pairwise inequality measures can be calculated using the `group_diff` function. The function requires a fitted **surveil** model and character strings corresponding, respectively, to the target population (indicating which group is the target of our *inference*, typically the overburdened or disadvantaged group), and the reference population. It returns probability distributions and summary statements for the following quantities:

 * Rate Difference (RD): $\text{RD} = \text{Target} - \text{Reference}$, 
 * Population Attributable Risk (PAR): $\text{PAR} = \frac{\text{RD}}{\text{Target}}$, 
 * Rate Ratio (RR): $\text{RR} = \frac{\text{Target}}{\text{Reference}}$, and 
 * Excess Cases (EC): $\text{EC} = \text{RD} \times \text{[At Risk]}$.
 
In the above equations, Target and Reference indicate the trend level of risk (rate) for the respective populations. Note that the PAR indicates the fraction of risk in the target population that would have been removed had the target rate equaled the reference rate. For $RR \ge 1$, $\text{PAR} = 1 - \text{RR}^{-1}$. 

```{r}
gd <- group_diff(fit, target = "Black or African American", reference = "White")
print(gd, rate_scale = 100e3)
```

The plot method for `surveil_diff` produces one time series ``ggplot`` each for RD, one of PAR or RR, and EC. The means of the probability distributions for each measure are plotted as lines, while the shading indicates a 95\% credible interval:

```{r fig.width = 3.5, fig.height = 4.5}
plot(gd, scale = 100e3)
```

## Measuring inequality with multiple groups

Pairwise measures are important, but they cannot provide a summary of inequality across multiple socially situated groups. Theil's T is an entropy-based inequality index with many favorable qualities, including that it naturally accommodates complex grouping structures.

Theil's T measures the extent to which certain populations are overburdened by disease, meaning precisely that the proportion of cases accounted for by a particular group, $\omega_j$, is higher than the proportion of the population constituted by that same group, $\eta_j$. With $k$ groups, Theil's index is
                               $$T = \sum_{j=1}^k \omega_j \big[ log(\omega_j / \eta_j) \big].$$
This is zero when case shares equal population shares and it increases monotonically as the two diverge for any group. Theilâ€™s T is thus a weighted mean of log-ratios of case shares to population shares, where each log-ratio (which we may describe as a raw inequality score) is weighted by its share of total cases.

Theil's T can be computed from a fitted **surveil** model, the only requirement is that the model includes multiple groups (through the `group` argument):

```{r}
Ts <- theil(fit)
print(Ts)
```

The time series of Theil's T can be plotted with 95\% credible intervals:

```{r fig.width = 4, fig.height = 3}
plot(Ts)
```

## Nested data structures

```{r eval = FALSE}
cities <- unique(msa$MSA)
fit_list <- lapply(cities, function(c) {
  stan_rw(msa[grepl(c, msa$MSA), ], 
          time = Year, 
          group = Race, 
          cor = TRUE, 
          cores = 4, 
          control = list(max_treedepth = 12, adapt_delta = 0.99))
})

austin <- fit_list[[1]]

df_list <- lapply(fit_list, function(x) x$summary)

bind_rows(df_list) %>%
  ggplot(aes(time, mean, group = Race)) +
  geom_line(aes(col = Race)) +
  geom_ribbon(aes(ymin = lwr_2.5, ymax = upr_97.5),
              alpha = 0.25,
              fill = "black"
              ) +
  geom_point(aes(time, Crude, col = Race),
             alpha = 0.5) +
  scale_y_continuous(name = NULL,
                    breaks = seq(0, 1, by = 0.0005),
                    labels = seq(0, 1, by = 0.0005) * 100e3
                     ) +
  scale_color_brewer(
    palette = "Dark2",
    type = "qual",
    name = NULL
  ) +
  labs(x = NULL) +
  theme_classic() +
  theme(legend.position = "bottom") +
  facet_wrap(~ MSA, nrow = 1)

t <- theil(fit_list)
plot(t)
```

## References

